// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::query::sql::metamodel::*;

function meta::external::store::relational::sqlDialectTranslation::defaults::windowFrameProcessor_default(): NodeProcessor<meta::external::query::sql::metamodel::WindowFrame>[1]
{
  nodeProcessor(
    meta::external::query::sql::metamodel::WindowFrame,
    {sqlDialect, wf, state, config |
      let sep0 = $state.separator(0, $config);
      let sep1 = $state.separator(1, $config);
      
      let modeStr = $wf.mode->match([
        m: meta::external::query::sql::metamodel::WindowFrameMode[1] | $m->toString()->toLower()
      ]);
      
      let startStr = $sqlDialect->executeNodeProcessor($wf.start, [], $state, $config);
      
      let endStr = if($wf.end->isEmpty(),
        | '',
        | ' ' + $sqlDialect->keyword('and', $state, $config) + ' ' + $sqlDialect->executeNodeProcessor($wf.end->toOne(), [], $state, $config)
      );
      
      $sqlDialect->keyword($modeStr, $state, $config) + ' ' + 
      if($wf.end->isEmpty(),
        | $startStr,
        | $sqlDialect->keyword('between', $state, $config) + ' ' + $startStr + $endStr
      );
    }
  )
}

function meta::external::store::relational::sqlDialectTranslation::defaults::frameBoundProcessor_default(): NodeProcessor<meta::external::query::sql::metamodel::FrameBound>[1]
{
  nodeProcessor(
    meta::external::query::sql::metamodel::FrameBound,
    {sqlDialect, fb, state, config |
      let boundTypeStr = $fb.type->match([
        t: meta::external::query::sql::metamodel::FrameBoundType[1] | 
          if($t == meta::external::query::sql::metamodel::FrameBoundType.CURRENT_ROW,
            | $sqlDialect->keyword('current row', $state, $config),
            | if($t == meta::external::query::sql::metamodel::FrameBoundType.UNBOUNDED_PRECEDING,
                | $sqlDialect->keyword('unbounded preceding', $state, $config),
                | if($t == meta::external::query::sql::metamodel::FrameBoundType.UNBOUNDED_FOLLOWING,
                    | $sqlDialect->keyword('unbounded following', $state, $config),
                    | if($t == meta::external::query::sql::metamodel::FrameBoundType.PRECEDING,
                        | $sqlDialect->executeNodeProcessor($fb.value->toOne(), [], $state, $config) + ' ' + $sqlDialect->keyword('preceding', $state, $config),
                        | if($t == meta::external::query::sql::metamodel::FrameBoundType.FOLLOWING,
                            | $sqlDialect->executeNodeProcessor($fb.value->toOne(), [], $state, $config) + ' ' + $sqlDialect->keyword('following', $state, $config),
                            | fail('Unsupported frame bound type: ' + $t->toString()); ''
                          )
                      )
                  )
              )
          )
      ]);
      
      $boundTypeStr;
    }
  )
}
