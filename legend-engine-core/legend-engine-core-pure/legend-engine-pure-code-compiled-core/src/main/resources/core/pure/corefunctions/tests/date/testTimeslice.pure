// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function <<test.Test, PCT.test>> meta::pure::functions::date::tests::timeslice::testTimesliceBasic<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
  let expr = {|
    let tds = #TDS
                timestamp
                2023-03-15T14:30:45.123+0000
                2023-07-22T08:15:30.456+0000
                2023-11-05T23:59:59.999+0000
                2023-01-01T00:00:00.000+0000
             #;
    $tds->extend([
      col(x | $x.timestamp->timeslice('YEAR'), 'year_slice'),
      col(x | $x.timestamp->timeslice('QUARTER'), 'quarter_slice'),
      col(x | $x.timestamp->timeslice('MONTH'), 'month_slice'),
      col(x | $x.timestamp->timeslice('DAY'), 'day_slice'),
      col(x | $x.timestamp->timeslice('HOUR'), 'hour_slice'),
      col(x | $x.timestamp->timeslice('MINUTE'), 'minute_slice'),
      col(x | $x.timestamp->timeslice('SECOND'), 'second_slice'),
      col(x | $x.timestamp->timeslice('MILLISECOND'), 'millisecond_slice')
    ]);
  };
  
  let res = $f->eval($expr);
  
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(0).values->at(1));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(1).values->at(1));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(2).values->at(1));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(1));
  
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(0).values->at(2));
  assertEquals(2023-07-01T00:00:00.000+0000, $res.rows->at(1).values->at(2));
  assertEquals(2023-10-01T00:00:00.000+0000, $res.rows->at(2).values->at(2));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(2));
  
  assertEquals(2023-03-01T00:00:00.000+0000, $res.rows->at(0).values->at(3));
  assertEquals(2023-07-01T00:00:00.000+0000, $res.rows->at(1).values->at(3));
  assertEquals(2023-11-01T00:00:00.000+0000, $res.rows->at(2).values->at(3));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(3));
  
  assertEquals(2023-03-15T00:00:00.000+0000, $res.rows->at(0).values->at(4));
  assertEquals(2023-07-22T00:00:00.000+0000, $res.rows->at(1).values->at(4));
  assertEquals(2023-11-05T00:00:00.000+0000, $res.rows->at(2).values->at(4));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(4));
  
  assertEquals(2023-03-15T14:00:00.000+0000, $res.rows->at(0).values->at(5));
  assertEquals(2023-07-22T08:00:00.000+0000, $res.rows->at(1).values->at(5));
  assertEquals(2023-11-05T23:00:00.000+0000, $res.rows->at(2).values->at(5));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(5));
  
  assertEquals(2023-03-15T14:30:00.000+0000, $res.rows->at(0).values->at(6));
  assertEquals(2023-07-22T08:15:00.000+0000, $res.rows->at(1).values->at(6));
  assertEquals(2023-11-05T23:59:00.000+0000, $res.rows->at(2).values->at(6));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(6));
  
  assertEquals(2023-03-15T14:30:45.000+0000, $res.rows->at(0).values->at(7));
  assertEquals(2023-07-22T08:15:30.000+0000, $res.rows->at(1).values->at(7));
  assertEquals(2023-11-05T23:59:59.000+0000, $res.rows->at(2).values->at(7));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(7));
  
  assertEquals(2023-03-15T14:30:45.123+0000, $res.rows->at(0).values->at(8));
  assertEquals(2023-07-22T08:15:30.456+0000, $res.rows->at(1).values->at(8));
  assertEquals(2023-11-05T23:59:59.999+0000, $res.rows->at(2).values->at(8));
  assertEquals(2023-01-01T00:00:00.000+0000, $res.rows->at(3).values->at(8));
}

function <<test.Test, PCT.test>> meta::pure::functions::date::tests::timeslice::testTimesliceWithTimezone<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
  let expr = {|
    let tds = #TDS
                timestamp
                2023-03-15T14:30:45.123+0000
             #;
    $tds->extend([
      col(x | $x.timestamp->timeslice('DAY', 'America/New_York'), 'day_slice_ny'),
      col(x | $x.timestamp->timeslice('DAY', 'Europe/London'), 'day_slice_london')
    ]);
  };
  
  let res = $f->eval($expr);
  
  // Adjust expected values based on timezone conversions
  assertEquals(2023-03-15T00:00:00.000-0400, $res.rows->at(0).values->at(1));
  assertEquals(2023-03-15T00:00:00.000+0000, $res.rows->at(0).values->at(2));
}

function <<test.Test, PCT.test>> meta::pure::functions::date::tests::timeslice::testTimesliceInvalidInterval<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
  let expr = {|
    let tds = #TDS
                timestamp
                2023-03-15T14:30:45.123+0000
             #;
    $tds->extend([
      col(x | $x.timestamp->timeslice('INVALID_INTERVAL'), 'invalid_slice')
    ]);
  };
  
  assertFalse($f->eval($expr)->instanceOf(TDS));
}
