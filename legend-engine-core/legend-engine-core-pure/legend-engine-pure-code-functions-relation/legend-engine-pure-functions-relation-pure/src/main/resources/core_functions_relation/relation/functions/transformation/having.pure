// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::metamodel::relation::*;
import meta::pure::functions::relation::*;
import meta::pure::functions::collection::*;
import meta::pure::functions::meta::*;
import meta::pure::functions::lang::*;
import meta::pure::functions::boolean::*;
import meta::pure::functions::math::*;
import meta::pure::tds::*;

/**
 * Filter a relation based on a condition applied to each row after grouping.
 * This is typically used after a groupBy operation to filter the results based on aggregate values.
 *
 * @param relation - The relation to filter
 * @param condition - A function that takes a row and returns a Boolean indicating whether to keep the row
 * @return A new relation containing only the rows that satisfy the condition
 */
native function meta::pure::functions::relation::having<T>(relation:Relation<T>[1], condition:Function<{T[1]->Boolean[1]}>[1]):Relation<T>[1];

/**
 * Example of using having with groupBy to filter groups based on aggregate values
 */
function <<test.Test>> meta::pure::functions::relation::tests::having::testHavingWithGroupBy():Boolean[1]
{
   let tds = [
      ^TDSRow(values = [^TDSString(value='A'), ^TDSInteger(value=1), ^TDSDecimal(value=10.5)]),
      ^TDSRow(values = [^TDSString(value='A'), ^TDSInteger(value=2), ^TDSDecimal(value=20.5)]),
      ^TDSRow(values = [^TDSString(value='B'), ^TDSInteger(value=3), ^TDSDecimal(value=30.5)]),
      ^TDSRow(values = [^TDSString(value='B'), ^TDSInteger(value=4), ^TDSDecimal(value=40.5)]),
      ^TDSRow(values = [^TDSString(value='C'), ^TDSInteger(value=5), ^TDSDecimal(value=50.5)])
   ]->meta::pure::functions::relation::tdsRows();
   
   let cols = [
      ^TDSColumn(name='group', offset=0, type=^meta::pure::metamodel::type::String()),
      ^TDSColumn(name='id', offset=1, type=^meta::pure::metamodel::type::Integer()),
      ^TDSColumn(name='value', offset=2, type=^meta::pure::metamodel::type::Float())
   ];
   
   let relation = ^TabularDataSet(rows=$tds, columns=$cols);
   
   // Group by 'group' column and calculate sum of 'value' column
   let grouped = $relation->groupBy([r | $r.getString('group')], [agg(r | $r.getFloat('value'), y | $y->sum())]);
   
   // Filter groups where sum of 'value' is greater than 50
   let filtered = $grouped->having({r | $r.getFloat('value') > 50.0});
   
   // Should only include groups A and B (their sums are 31.0 and 71.0)
   assertEquals(2, $filtered->meta::pure::functions::relation::columnValueSize());
   
   let values = $filtered->project([col(r | $r.getString('group'), 'group'), col(r | $r.getFloat('value'), 'value')]);
   
   // Verify the groups and their sums
   assertEquals(['A', 'B'], $values->project([col(r | $r.getString('group'), 'group')])->meta::pure::functions::relation::toOne()->sort());
   
   let aSum = $values->filter(r | $r.getString('group') == 'A')->toOne().getFloat('value');
   let bSum = $values->filter(r | $r.getString('group') == 'B')->toOne().getFloat('value');
   
   assertEquals(31.0, $aSum);
   assertEquals(71.0, $bSum);
   
   true;
}

/**
 * Test having with multiple conditions
 */
function <<test.Test>> meta::pure::functions::relation::tests::having::testHavingWithMultipleConditions():Boolean[1]
{
   let tds = [
      ^TDSRow(values = [^TDSString(value='A'), ^TDSInteger(value=1), ^TDSDecimal(value=10.5)]),
      ^TDSRow(values = [^TDSString(value='A'), ^TDSInteger(value=2), ^TDSDecimal(value=20.5)]),
      ^TDSRow(values = [^TDSString(value='B'), ^TDSInteger(value=3), ^TDSDecimal(value=30.5)]),
      ^TDSRow(values = [^TDSString(value='B'), ^TDSInteger(value=4), ^TDSDecimal(value=40.5)]),
      ^TDSRow(values = [^TDSString(value='C'), ^TDSInteger(value=5), ^TDSDecimal(value=50.5)])
   ]->meta::pure::functions::relation::tdsRows();
   
   let cols = [
      ^TDSColumn(name='group', offset=0, type=^meta::pure::metamodel::type::String()),
      ^TDSColumn(name='id', offset=1, type=^meta::pure::metamodel::type::Integer()),
      ^TDSColumn(name='value', offset=2, type=^meta::pure::metamodel::type::Float())
   ];
   
   let relation = ^TabularDataSet(rows=$tds, columns=$cols);
   
   // Group by 'group' column and calculate sum of 'value' and count of rows
   let grouped = $relation->groupBy(
      [r | $r.getString('group')], 
      [agg(r | $r.getFloat('value'), y | $y->sum()), 
       agg(r | $r.getInteger('id'), y | $y->count())]
   );
   
   // Filter groups where sum of 'value' is greater than 30 AND count is greater than 1
   let filtered = $grouped->having({r | $r.getFloat('value') > 30.0 && $r.getInteger('id_count') > 1});
   
   // Should only include group B (sum=71.0, count=2)
   assertEquals(1, $filtered->meta::pure::functions::relation::columnValueSize());
   
   let values = $filtered->project([
      col(r | $r.getString('group'), 'group'), 
      col(r | $r.getFloat('value'), 'value'),
      col(r | $r.getInteger('id_count'), 'count')
   ]);
   
   assertEquals('B', $values->toOne().getString('group'));
   assertEquals(71.0, $values->toOne().getFloat('value'));
   assertEquals(2, $values->toOne().getInteger('count'));
   
   true;
}

/**
 * Test having with OR condition
 */
function <<test.Test>> meta::pure::functions::relation::tests::having::testHavingWithOrCondition():Boolean[1]
{
   let tds = [
      ^TDSRow(values = [^TDSString(value='A'), ^TDSInteger(value=1), ^TDSDecimal(value=10.5)]),
      ^TDSRow(values = [^TDSString(value='A'), ^TDSInteger(value=2), ^TDSDecimal(value=20.5)]),
      ^TDSRow(values = [^TDSString(value='B'), ^TDSInteger(value=3), ^TDSDecimal(value=30.5)]),
      ^TDSRow(values = [^TDSString(value='B'), ^TDSInteger(value=4), ^TDSDecimal(value=40.5)]),
      ^TDSRow(values = [^TDSString(value='C'), ^TDSInteger(value=5), ^TDSDecimal(value=50.5)])
   ]->meta::pure::functions::relation::tdsRows();
   
   let cols = [
      ^TDSColumn(name='group', offset=0, type=^meta::pure::metamodel::type::String()),
      ^TDSColumn(name='id', offset=1, type=^meta::pure::metamodel::type::Integer()),
      ^TDSColumn(name='value', offset=2, type=^meta::pure::metamodel::type::Float())
   ];
   
   let relation = ^TabularDataSet(rows=$tds, columns=$cols);
   
   // Group by 'group' column and calculate sum of 'value' and count of rows
   let grouped = $relation->groupBy(
      [r | $r.getString('group')], 
      [agg(r | $r.getFloat('value'), y | $y->sum()), 
       agg(r | $r.getInteger('id'), y | $y->count())]
   );
   
   // Filter groups where sum of 'value' is greater than 50 OR count is equal to 1
   let filtered = $grouped->having({r | $r.getFloat('value') > 50.0 || $r.getInteger('id_count') == 1});
   
   // Should include groups B and C (B: sum=71.0, count=2; C: sum=50.5, count=1)
   assertEquals(2, $filtered->meta::pure::functions::relation::columnValueSize());
   
   let values = $filtered->project([
      col(r | $r.getString('group'), 'group'), 
      col(r | $r.getFloat('value'), 'value'),
      col(r | $r.getInteger('id_count'), 'count')
   ]);
   
   assertEquals(['B', 'C'], $values->project([col(r | $r.getString('group'), 'group')])->meta::pure::functions::relation::toOne()->sort());
   
   true;
}
